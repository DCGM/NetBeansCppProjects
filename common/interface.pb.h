// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interface.proto

#ifndef PROTOBUF_interface_2eproto__INCLUDED
#define PROTOBUF_interface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protointerface {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_interface_2eproto();
void protobuf_AssignDesc_interface_2eproto();
void protobuf_ShutdownFile_interface_2eproto();

class FEConfiguration;
class TranslateConfiguration;
class MatchConfiguration;
class CaffeConfiguration;
class Configuration;
class BlobFloat;
class ResultList;
class WorkRequest;

// ===================================================================

class FEConfiguration : public ::google::protobuf::Message {
 public:
  FEConfiguration();
  virtual ~FEConfiguration();

  FEConfiguration(const FEConfiguration& from);

  inline FEConfiguration& operator=(const FEConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FEConfiguration& default_instance();

  void Swap(FEConfiguration* other);

  // implements Message ----------------------------------------------

  FEConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FEConfiguration& from);
  void MergeFrom(const FEConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protointerface.FEConfiguration)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static FEConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class TranslateConfiguration : public ::google::protobuf::Message {
 public:
  TranslateConfiguration();
  virtual ~TranslateConfiguration();

  TranslateConfiguration(const TranslateConfiguration& from);

  inline TranslateConfiguration& operator=(const TranslateConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslateConfiguration& default_instance();

  void Swap(TranslateConfiguration* other);

  // implements Message ----------------------------------------------

  TranslateConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslateConfiguration& from);
  void MergeFrom(const TranslateConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 neighborCount = 1 [default = 1];
  inline bool has_neighborcount() const;
  inline void clear_neighborcount();
  static const int kNeighborCountFieldNumber = 1;
  inline ::google::protobuf::uint32 neighborcount() const;
  inline void set_neighborcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protointerface.TranslateConfiguration)
 private:
  inline void set_has_neighborcount();
  inline void clear_has_neighborcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 neighborcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static TranslateConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class MatchConfiguration : public ::google::protobuf::Message {
 public:
  MatchConfiguration();
  virtual ~MatchConfiguration();

  MatchConfiguration(const MatchConfiguration& from);

  inline MatchConfiguration& operator=(const MatchConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchConfiguration& default_instance();

  void Swap(MatchConfiguration* other);

  // implements Message ----------------------------------------------

  MatchConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchConfiguration& from);
  void MergeFrom(const MatchConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 listSize = 1 [default = 100];
  inline bool has_listsize() const;
  inline void clear_listsize();
  static const int kListSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 listsize() const;
  inline void set_listsize(::google::protobuf::uint32 value);

  // optional string database = 2 [default = ""];
  inline bool has_database() const;
  inline void clear_database();
  static const int kDatabaseFieldNumber = 2;
  inline const ::std::string& database() const;
  inline void set_database(const ::std::string& value);
  inline void set_database(const char* value);
  inline void set_database(const char* value, size_t size);
  inline ::std::string* mutable_database();
  inline ::std::string* release_database();
  inline void set_allocated_database(::std::string* database);

  // @@protoc_insertion_point(class_scope:protointerface.MatchConfiguration)
 private:
  inline void set_has_listsize();
  inline void clear_has_listsize();
  inline void set_has_database();
  inline void clear_has_database();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* database_;
  ::google::protobuf::uint32 listsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static MatchConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class CaffeConfiguration : public ::google::protobuf::Message {
 public:
  CaffeConfiguration();
  virtual ~CaffeConfiguration();

  CaffeConfiguration(const CaffeConfiguration& from);

  inline CaffeConfiguration& operator=(const CaffeConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeConfiguration& default_instance();

  void Swap(CaffeConfiguration* other);

  // implements Message ----------------------------------------------

  CaffeConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeConfiguration& from);
  void MergeFrom(const CaffeConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 resultSize = 1 [default = 5];
  inline bool has_resultsize() const;
  inline void clear_resultsize();
  static const int kResultSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 resultsize() const;
  inline void set_resultsize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protointerface.CaffeConfiguration)
 private:
  inline void set_has_resultsize();
  inline void clear_has_resultsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 resultsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static CaffeConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string queue = 1;
  inline bool has_queue() const;
  inline void clear_queue();
  static const int kQueueFieldNumber = 1;
  inline const ::std::string& queue() const;
  inline void set_queue(const ::std::string& value);
  inline void set_queue(const char* value);
  inline void set_queue(const char* value, size_t size);
  inline ::std::string* mutable_queue();
  inline ::std::string* release_queue();
  inline void set_allocated_queue(::std::string* queue);

  // optional .protointerface.FEConfiguration fe = 2;
  inline bool has_fe() const;
  inline void clear_fe();
  static const int kFeFieldNumber = 2;
  inline const ::protointerface::FEConfiguration& fe() const;
  inline ::protointerface::FEConfiguration* mutable_fe();
  inline ::protointerface::FEConfiguration* release_fe();
  inline void set_allocated_fe(::protointerface::FEConfiguration* fe);

  // optional .protointerface.TranslateConfiguration translate = 3;
  inline bool has_translate() const;
  inline void clear_translate();
  static const int kTranslateFieldNumber = 3;
  inline const ::protointerface::TranslateConfiguration& translate() const;
  inline ::protointerface::TranslateConfiguration* mutable_translate();
  inline ::protointerface::TranslateConfiguration* release_translate();
  inline void set_allocated_translate(::protointerface::TranslateConfiguration* translate);

  // optional .protointerface.MatchConfiguration match = 4;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 4;
  inline const ::protointerface::MatchConfiguration& match() const;
  inline ::protointerface::MatchConfiguration* mutable_match();
  inline ::protointerface::MatchConfiguration* release_match();
  inline void set_allocated_match(::protointerface::MatchConfiguration* match);

  // optional .protointerface.CaffeConfiguration caffe = 5;
  inline bool has_caffe() const;
  inline void clear_caffe();
  static const int kCaffeFieldNumber = 5;
  inline const ::protointerface::CaffeConfiguration& caffe() const;
  inline ::protointerface::CaffeConfiguration* mutable_caffe();
  inline ::protointerface::CaffeConfiguration* release_caffe();
  inline void set_allocated_caffe(::protointerface::CaffeConfiguration* caffe);

  // @@protoc_insertion_point(class_scope:protointerface.Configuration)
 private:
  inline void set_has_queue();
  inline void clear_has_queue();
  inline void set_has_fe();
  inline void clear_has_fe();
  inline void set_has_translate();
  inline void clear_has_translate();
  inline void set_has_match();
  inline void clear_has_match();
  inline void set_has_caffe();
  inline void clear_has_caffe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* queue_;
  ::protointerface::FEConfiguration* fe_;
  ::protointerface::TranslateConfiguration* translate_;
  ::protointerface::MatchConfiguration* match_;
  ::protointerface::CaffeConfiguration* caffe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class BlobFloat : public ::google::protobuf::Message {
 public:
  BlobFloat();
  virtual ~BlobFloat();

  BlobFloat(const BlobFloat& from);

  inline BlobFloat& operator=(const BlobFloat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobFloat& default_instance();

  void Swap(BlobFloat* other);

  // implements Message ----------------------------------------------

  BlobFloat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobFloat& from);
  void MergeFrom(const BlobFloat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dim = 1 [packed = true];
  inline int dim_size() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 1;
  inline ::google::protobuf::uint32 dim(int index) const;
  inline void set_dim(int index, ::google::protobuf::uint32 value);
  inline void add_dim(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dim() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dim();

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:protointerface.BlobFloat)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dim_;
  mutable int _dim_cached_byte_size_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static BlobFloat* default_instance_;
};
// -------------------------------------------------------------------

class ResultList : public ::google::protobuf::Message {
 public:
  ResultList();
  virtual ~ResultList();

  ResultList(const ResultList& from);

  inline ResultList& operator=(const ResultList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultList& default_instance();

  void Swap(ResultList* other);

  // implements Message ----------------------------------------------

  ResultList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultList& from);
  void MergeFrom(const ResultList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float score = 1 [packed = true];
  inline int score_size() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline float score(int index) const;
  inline void set_score(int index, float value);
  inline void add_score(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      score() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_score();

  // repeated string url = 2;
  inline int url_size() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url(int index) const;
  inline ::std::string* mutable_url(int index);
  inline void set_url(int index, const ::std::string& value);
  inline void set_url(int index, const char* value);
  inline void set_url(int index, const char* value, size_t size);
  inline ::std::string* add_url();
  inline void add_url(const ::std::string& value);
  inline void add_url(const char* value);
  inline void add_url(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& url() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_url();

  // @@protoc_insertion_point(class_scope:protointerface.ResultList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > score_;
  mutable int _score_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static ResultList* default_instance_;
};
// -------------------------------------------------------------------

class WorkRequest : public ::google::protobuf::Message {
 public:
  WorkRequest();
  virtual ~WorkRequest();

  WorkRequest(const WorkRequest& from);

  inline WorkRequest& operator=(const WorkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkRequest& default_instance();

  void Swap(WorkRequest* other);

  // implements Message ----------------------------------------------

  WorkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkRequest& from);
  void MergeFrom(const WorkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional double timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // repeated .protointerface.Configuration configuration = 3;
  inline int configuration_size() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 3;
  inline const ::protointerface::Configuration& configuration(int index) const;
  inline ::protointerface::Configuration* mutable_configuration(int index);
  inline ::protointerface::Configuration* add_configuration();
  inline const ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >&
      configuration() const;
  inline ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >*
      mutable_configuration();

  // repeated .protointerface.Configuration pastConfiguration = 5;
  inline int pastconfiguration_size() const;
  inline void clear_pastconfiguration();
  static const int kPastConfigurationFieldNumber = 5;
  inline const ::protointerface::Configuration& pastconfiguration(int index) const;
  inline ::protointerface::Configuration* mutable_pastconfiguration(int index);
  inline ::protointerface::Configuration* add_pastconfiguration();
  inline const ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >&
      pastconfiguration() const;
  inline ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >*
      mutable_pastconfiguration();

  // optional uint32 errorCode = 6 [default = 0];
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 6;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // repeated string message = 7;
  inline int message_size() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 7;
  inline const ::std::string& message(int index) const;
  inline ::std::string* mutable_message(int index);
  inline void set_message(int index, const ::std::string& value);
  inline void set_message(int index, const char* value);
  inline void set_message(int index, const char* value, size_t size);
  inline ::std::string* add_message();
  inline void add_message(const ::std::string& value);
  inline void add_message(const char* value);
  inline void add_message(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& message() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_message();

  // optional string returnQueue = 8;
  inline bool has_returnqueue() const;
  inline void clear_returnqueue();
  static const int kReturnQueueFieldNumber = 8;
  inline const ::std::string& returnqueue() const;
  inline void set_returnqueue(const ::std::string& value);
  inline void set_returnqueue(const char* value);
  inline void set_returnqueue(const char* value, size_t size);
  inline ::std::string* mutable_returnqueue();
  inline ::std::string* release_returnqueue();
  inline void set_allocated_returnqueue(::std::string* returnqueue);

  // optional bytes image = 17;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 17;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const void* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional .protointerface.BlobFloat blob = 18;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 18;
  inline const ::protointerface::BlobFloat& blob() const;
  inline ::protointerface::BlobFloat* mutable_blob();
  inline ::protointerface::BlobFloat* release_blob();
  inline void set_allocated_blob(::protointerface::BlobFloat* blob);

  // optional .protointerface.ResultList result = 19;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 19;
  inline const ::protointerface::ResultList& result() const;
  inline ::protointerface::ResultList* mutable_result();
  inline ::protointerface::ResultList* release_result();
  inline void set_allocated_result(::protointerface::ResultList* result);

  // @@protoc_insertion_point(class_scope:protointerface.WorkRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_returnqueue();
  inline void clear_has_returnqueue();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_blob();
  inline void clear_has_blob();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  double timestamp_;
  ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration > configuration_;
  ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration > pastconfiguration_;
  ::google::protobuf::RepeatedPtrField< ::std::string> message_;
  ::std::string* returnqueue_;
  ::std::string* image_;
  ::protointerface::BlobFloat* blob_;
  ::protointerface::ResultList* result_;
  ::google::protobuf::uint32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static WorkRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// FEConfiguration

// -------------------------------------------------------------------

// TranslateConfiguration

// optional uint32 neighborCount = 1 [default = 1];
inline bool TranslateConfiguration::has_neighborcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranslateConfiguration::set_has_neighborcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranslateConfiguration::clear_has_neighborcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranslateConfiguration::clear_neighborcount() {
  neighborcount_ = 1u;
  clear_has_neighborcount();
}
inline ::google::protobuf::uint32 TranslateConfiguration::neighborcount() const {
  return neighborcount_;
}
inline void TranslateConfiguration::set_neighborcount(::google::protobuf::uint32 value) {
  set_has_neighborcount();
  neighborcount_ = value;
}

// -------------------------------------------------------------------

// MatchConfiguration

// optional uint32 listSize = 1 [default = 100];
inline bool MatchConfiguration::has_listsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchConfiguration::set_has_listsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchConfiguration::clear_has_listsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchConfiguration::clear_listsize() {
  listsize_ = 100u;
  clear_has_listsize();
}
inline ::google::protobuf::uint32 MatchConfiguration::listsize() const {
  return listsize_;
}
inline void MatchConfiguration::set_listsize(::google::protobuf::uint32 value) {
  set_has_listsize();
  listsize_ = value;
}

// optional string database = 2 [default = ""];
inline bool MatchConfiguration::has_database() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchConfiguration::set_has_database() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchConfiguration::clear_has_database() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchConfiguration::clear_database() {
  if (database_ != &::google::protobuf::internal::kEmptyString) {
    database_->clear();
  }
  clear_has_database();
}
inline const ::std::string& MatchConfiguration::database() const {
  return *database_;
}
inline void MatchConfiguration::set_database(const ::std::string& value) {
  set_has_database();
  if (database_ == &::google::protobuf::internal::kEmptyString) {
    database_ = new ::std::string;
  }
  database_->assign(value);
}
inline void MatchConfiguration::set_database(const char* value) {
  set_has_database();
  if (database_ == &::google::protobuf::internal::kEmptyString) {
    database_ = new ::std::string;
  }
  database_->assign(value);
}
inline void MatchConfiguration::set_database(const char* value, size_t size) {
  set_has_database();
  if (database_ == &::google::protobuf::internal::kEmptyString) {
    database_ = new ::std::string;
  }
  database_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchConfiguration::mutable_database() {
  set_has_database();
  if (database_ == &::google::protobuf::internal::kEmptyString) {
    database_ = new ::std::string;
  }
  return database_;
}
inline ::std::string* MatchConfiguration::release_database() {
  clear_has_database();
  if (database_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = database_;
    database_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchConfiguration::set_allocated_database(::std::string* database) {
  if (database_ != &::google::protobuf::internal::kEmptyString) {
    delete database_;
  }
  if (database) {
    set_has_database();
    database_ = database;
  } else {
    clear_has_database();
    database_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CaffeConfiguration

// optional uint32 resultSize = 1 [default = 5];
inline bool CaffeConfiguration::has_resultsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeConfiguration::set_has_resultsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeConfiguration::clear_has_resultsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeConfiguration::clear_resultsize() {
  resultsize_ = 5u;
  clear_has_resultsize();
}
inline ::google::protobuf::uint32 CaffeConfiguration::resultsize() const {
  return resultsize_;
}
inline void CaffeConfiguration::set_resultsize(::google::protobuf::uint32 value) {
  set_has_resultsize();
  resultsize_ = value;
}

// -------------------------------------------------------------------

// Configuration

// optional string queue = 1;
inline bool Configuration::has_queue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_queue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_queue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_queue() {
  if (queue_ != &::google::protobuf::internal::kEmptyString) {
    queue_->clear();
  }
  clear_has_queue();
}
inline const ::std::string& Configuration::queue() const {
  return *queue_;
}
inline void Configuration::set_queue(const ::std::string& value) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(value);
}
inline void Configuration::set_queue(const char* value) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(value);
}
inline void Configuration::set_queue(const char* value, size_t size) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Configuration::mutable_queue() {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  return queue_;
}
inline ::std::string* Configuration::release_queue() {
  clear_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = queue_;
    queue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Configuration::set_allocated_queue(::std::string* queue) {
  if (queue_ != &::google::protobuf::internal::kEmptyString) {
    delete queue_;
  }
  if (queue) {
    set_has_queue();
    queue_ = queue;
  } else {
    clear_has_queue();
    queue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protointerface.FEConfiguration fe = 2;
inline bool Configuration::has_fe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configuration::set_has_fe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configuration::clear_has_fe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configuration::clear_fe() {
  if (fe_ != NULL) fe_->::protointerface::FEConfiguration::Clear();
  clear_has_fe();
}
inline const ::protointerface::FEConfiguration& Configuration::fe() const {
  return fe_ != NULL ? *fe_ : *default_instance_->fe_;
}
inline ::protointerface::FEConfiguration* Configuration::mutable_fe() {
  set_has_fe();
  if (fe_ == NULL) fe_ = new ::protointerface::FEConfiguration;
  return fe_;
}
inline ::protointerface::FEConfiguration* Configuration::release_fe() {
  clear_has_fe();
  ::protointerface::FEConfiguration* temp = fe_;
  fe_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_fe(::protointerface::FEConfiguration* fe) {
  delete fe_;
  fe_ = fe;
  if (fe) {
    set_has_fe();
  } else {
    clear_has_fe();
  }
}

// optional .protointerface.TranslateConfiguration translate = 3;
inline bool Configuration::has_translate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_translate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_translate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_translate() {
  if (translate_ != NULL) translate_->::protointerface::TranslateConfiguration::Clear();
  clear_has_translate();
}
inline const ::protointerface::TranslateConfiguration& Configuration::translate() const {
  return translate_ != NULL ? *translate_ : *default_instance_->translate_;
}
inline ::protointerface::TranslateConfiguration* Configuration::mutable_translate() {
  set_has_translate();
  if (translate_ == NULL) translate_ = new ::protointerface::TranslateConfiguration;
  return translate_;
}
inline ::protointerface::TranslateConfiguration* Configuration::release_translate() {
  clear_has_translate();
  ::protointerface::TranslateConfiguration* temp = translate_;
  translate_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_translate(::protointerface::TranslateConfiguration* translate) {
  delete translate_;
  translate_ = translate;
  if (translate) {
    set_has_translate();
  } else {
    clear_has_translate();
  }
}

// optional .protointerface.MatchConfiguration match = 4;
inline bool Configuration::has_match() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configuration::set_has_match() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configuration::clear_has_match() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configuration::clear_match() {
  if (match_ != NULL) match_->::protointerface::MatchConfiguration::Clear();
  clear_has_match();
}
inline const ::protointerface::MatchConfiguration& Configuration::match() const {
  return match_ != NULL ? *match_ : *default_instance_->match_;
}
inline ::protointerface::MatchConfiguration* Configuration::mutable_match() {
  set_has_match();
  if (match_ == NULL) match_ = new ::protointerface::MatchConfiguration;
  return match_;
}
inline ::protointerface::MatchConfiguration* Configuration::release_match() {
  clear_has_match();
  ::protointerface::MatchConfiguration* temp = match_;
  match_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_match(::protointerface::MatchConfiguration* match) {
  delete match_;
  match_ = match;
  if (match) {
    set_has_match();
  } else {
    clear_has_match();
  }
}

// optional .protointerface.CaffeConfiguration caffe = 5;
inline bool Configuration::has_caffe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configuration::set_has_caffe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configuration::clear_has_caffe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configuration::clear_caffe() {
  if (caffe_ != NULL) caffe_->::protointerface::CaffeConfiguration::Clear();
  clear_has_caffe();
}
inline const ::protointerface::CaffeConfiguration& Configuration::caffe() const {
  return caffe_ != NULL ? *caffe_ : *default_instance_->caffe_;
}
inline ::protointerface::CaffeConfiguration* Configuration::mutable_caffe() {
  set_has_caffe();
  if (caffe_ == NULL) caffe_ = new ::protointerface::CaffeConfiguration;
  return caffe_;
}
inline ::protointerface::CaffeConfiguration* Configuration::release_caffe() {
  clear_has_caffe();
  ::protointerface::CaffeConfiguration* temp = caffe_;
  caffe_ = NULL;
  return temp;
}
inline void Configuration::set_allocated_caffe(::protointerface::CaffeConfiguration* caffe) {
  delete caffe_;
  caffe_ = caffe;
  if (caffe) {
    set_has_caffe();
  } else {
    clear_has_caffe();
  }
}

// -------------------------------------------------------------------

// BlobFloat

// repeated uint32 dim = 1 [packed = true];
inline int BlobFloat::dim_size() const {
  return dim_.size();
}
inline void BlobFloat::clear_dim() {
  dim_.Clear();
}
inline ::google::protobuf::uint32 BlobFloat::dim(int index) const {
  return dim_.Get(index);
}
inline void BlobFloat::set_dim(int index, ::google::protobuf::uint32 value) {
  dim_.Set(index, value);
}
inline void BlobFloat::add_dim(::google::protobuf::uint32 value) {
  dim_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BlobFloat::dim() const {
  return dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BlobFloat::mutable_dim() {
  return &dim_;
}

// required bytes data = 2;
inline bool BlobFloat::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlobFloat::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlobFloat::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlobFloat::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& BlobFloat::data() const {
  return *data_;
}
inline void BlobFloat::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void BlobFloat::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void BlobFloat::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlobFloat::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* BlobFloat::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlobFloat::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResultList

// repeated float score = 1 [packed = true];
inline int ResultList::score_size() const {
  return score_.size();
}
inline void ResultList::clear_score() {
  score_.Clear();
}
inline float ResultList::score(int index) const {
  return score_.Get(index);
}
inline void ResultList::set_score(int index, float value) {
  score_.Set(index, value);
}
inline void ResultList::add_score(float value) {
  score_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ResultList::score() const {
  return score_;
}
inline ::google::protobuf::RepeatedField< float >*
ResultList::mutable_score() {
  return &score_;
}

// repeated string url = 2;
inline int ResultList::url_size() const {
  return url_.size();
}
inline void ResultList::clear_url() {
  url_.Clear();
}
inline const ::std::string& ResultList::url(int index) const {
  return url_.Get(index);
}
inline ::std::string* ResultList::mutable_url(int index) {
  return url_.Mutable(index);
}
inline void ResultList::set_url(int index, const ::std::string& value) {
  url_.Mutable(index)->assign(value);
}
inline void ResultList::set_url(int index, const char* value) {
  url_.Mutable(index)->assign(value);
}
inline void ResultList::set_url(int index, const char* value, size_t size) {
  url_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultList::add_url() {
  return url_.Add();
}
inline void ResultList::add_url(const ::std::string& value) {
  url_.Add()->assign(value);
}
inline void ResultList::add_url(const char* value) {
  url_.Add()->assign(value);
}
inline void ResultList::add_url(const char* value, size_t size) {
  url_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResultList::url() const {
  return url_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResultList::mutable_url() {
  return &url_;
}

// -------------------------------------------------------------------

// WorkRequest

// optional string uuid = 1;
inline bool WorkRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkRequest::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& WorkRequest::uuid() const {
  return *uuid_;
}
inline void WorkRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void WorkRequest::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void WorkRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkRequest::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* WorkRequest::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WorkRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double timestamp = 2;
inline bool WorkRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkRequest::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double WorkRequest::timestamp() const {
  return timestamp_;
}
inline void WorkRequest::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated .protointerface.Configuration configuration = 3;
inline int WorkRequest::configuration_size() const {
  return configuration_.size();
}
inline void WorkRequest::clear_configuration() {
  configuration_.Clear();
}
inline const ::protointerface::Configuration& WorkRequest::configuration(int index) const {
  return configuration_.Get(index);
}
inline ::protointerface::Configuration* WorkRequest::mutable_configuration(int index) {
  return configuration_.Mutable(index);
}
inline ::protointerface::Configuration* WorkRequest::add_configuration() {
  return configuration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >&
WorkRequest::configuration() const {
  return configuration_;
}
inline ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >*
WorkRequest::mutable_configuration() {
  return &configuration_;
}

// repeated .protointerface.Configuration pastConfiguration = 5;
inline int WorkRequest::pastconfiguration_size() const {
  return pastconfiguration_.size();
}
inline void WorkRequest::clear_pastconfiguration() {
  pastconfiguration_.Clear();
}
inline const ::protointerface::Configuration& WorkRequest::pastconfiguration(int index) const {
  return pastconfiguration_.Get(index);
}
inline ::protointerface::Configuration* WorkRequest::mutable_pastconfiguration(int index) {
  return pastconfiguration_.Mutable(index);
}
inline ::protointerface::Configuration* WorkRequest::add_pastconfiguration() {
  return pastconfiguration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >&
WorkRequest::pastconfiguration() const {
  return pastconfiguration_;
}
inline ::google::protobuf::RepeatedPtrField< ::protointerface::Configuration >*
WorkRequest::mutable_pastconfiguration() {
  return &pastconfiguration_;
}

// optional uint32 errorCode = 6 [default = 0];
inline bool WorkRequest::has_errorcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorkRequest::set_has_errorcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorkRequest::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorkRequest::clear_errorcode() {
  errorcode_ = 0u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 WorkRequest::errorcode() const {
  return errorcode_;
}
inline void WorkRequest::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// repeated string message = 7;
inline int WorkRequest::message_size() const {
  return message_.size();
}
inline void WorkRequest::clear_message() {
  message_.Clear();
}
inline const ::std::string& WorkRequest::message(int index) const {
  return message_.Get(index);
}
inline ::std::string* WorkRequest::mutable_message(int index) {
  return message_.Mutable(index);
}
inline void WorkRequest::set_message(int index, const ::std::string& value) {
  message_.Mutable(index)->assign(value);
}
inline void WorkRequest::set_message(int index, const char* value) {
  message_.Mutable(index)->assign(value);
}
inline void WorkRequest::set_message(int index, const char* value, size_t size) {
  message_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkRequest::add_message() {
  return message_.Add();
}
inline void WorkRequest::add_message(const ::std::string& value) {
  message_.Add()->assign(value);
}
inline void WorkRequest::add_message(const char* value) {
  message_.Add()->assign(value);
}
inline void WorkRequest::add_message(const char* value, size_t size) {
  message_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WorkRequest::message() const {
  return message_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WorkRequest::mutable_message() {
  return &message_;
}

// optional string returnQueue = 8;
inline bool WorkRequest::has_returnqueue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WorkRequest::set_has_returnqueue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WorkRequest::clear_has_returnqueue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WorkRequest::clear_returnqueue() {
  if (returnqueue_ != &::google::protobuf::internal::kEmptyString) {
    returnqueue_->clear();
  }
  clear_has_returnqueue();
}
inline const ::std::string& WorkRequest::returnqueue() const {
  return *returnqueue_;
}
inline void WorkRequest::set_returnqueue(const ::std::string& value) {
  set_has_returnqueue();
  if (returnqueue_ == &::google::protobuf::internal::kEmptyString) {
    returnqueue_ = new ::std::string;
  }
  returnqueue_->assign(value);
}
inline void WorkRequest::set_returnqueue(const char* value) {
  set_has_returnqueue();
  if (returnqueue_ == &::google::protobuf::internal::kEmptyString) {
    returnqueue_ = new ::std::string;
  }
  returnqueue_->assign(value);
}
inline void WorkRequest::set_returnqueue(const char* value, size_t size) {
  set_has_returnqueue();
  if (returnqueue_ == &::google::protobuf::internal::kEmptyString) {
    returnqueue_ = new ::std::string;
  }
  returnqueue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkRequest::mutable_returnqueue() {
  set_has_returnqueue();
  if (returnqueue_ == &::google::protobuf::internal::kEmptyString) {
    returnqueue_ = new ::std::string;
  }
  return returnqueue_;
}
inline ::std::string* WorkRequest::release_returnqueue() {
  clear_has_returnqueue();
  if (returnqueue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = returnqueue_;
    returnqueue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WorkRequest::set_allocated_returnqueue(::std::string* returnqueue) {
  if (returnqueue_ != &::google::protobuf::internal::kEmptyString) {
    delete returnqueue_;
  }
  if (returnqueue) {
    set_has_returnqueue();
    returnqueue_ = returnqueue;
  } else {
    clear_has_returnqueue();
    returnqueue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes image = 17;
inline bool WorkRequest::has_image() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WorkRequest::set_has_image() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WorkRequest::clear_has_image() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WorkRequest::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& WorkRequest::image() const {
  return *image_;
}
inline void WorkRequest::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void WorkRequest::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void WorkRequest::set_image(const void* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkRequest::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* WorkRequest::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WorkRequest::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protointerface.BlobFloat blob = 18;
inline bool WorkRequest::has_blob() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WorkRequest::set_has_blob() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WorkRequest::clear_has_blob() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WorkRequest::clear_blob() {
  if (blob_ != NULL) blob_->::protointerface::BlobFloat::Clear();
  clear_has_blob();
}
inline const ::protointerface::BlobFloat& WorkRequest::blob() const {
  return blob_ != NULL ? *blob_ : *default_instance_->blob_;
}
inline ::protointerface::BlobFloat* WorkRequest::mutable_blob() {
  set_has_blob();
  if (blob_ == NULL) blob_ = new ::protointerface::BlobFloat;
  return blob_;
}
inline ::protointerface::BlobFloat* WorkRequest::release_blob() {
  clear_has_blob();
  ::protointerface::BlobFloat* temp = blob_;
  blob_ = NULL;
  return temp;
}
inline void WorkRequest::set_allocated_blob(::protointerface::BlobFloat* blob) {
  delete blob_;
  blob_ = blob;
  if (blob) {
    set_has_blob();
  } else {
    clear_has_blob();
  }
}

// optional .protointerface.ResultList result = 19;
inline bool WorkRequest::has_result() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WorkRequest::set_has_result() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WorkRequest::clear_has_result() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WorkRequest::clear_result() {
  if (result_ != NULL) result_->::protointerface::ResultList::Clear();
  clear_has_result();
}
inline const ::protointerface::ResultList& WorkRequest::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::protointerface::ResultList* WorkRequest::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::protointerface::ResultList;
  return result_;
}
inline ::protointerface::ResultList* WorkRequest::release_result() {
  clear_has_result();
  ::protointerface::ResultList* temp = result_;
  result_ = NULL;
  return temp;
}
inline void WorkRequest::set_allocated_result(::protointerface::ResultList* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protointerface

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_interface_2eproto__INCLUDED
